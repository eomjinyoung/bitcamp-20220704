<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ex03</title>
</head>
<body>
<h1>함수 - 클로저(closure)와 바깥 함수의 로컬 변수</h1>
<script>
"use strict"
// 함수 안에 정의된 함수를 보통 클로저(closure)라 부른다.
// => inner functoin, nested function 이라고도 표현한다.
// => 클로저의 핵심 개념 
//    closure에서 바깥 함수의 로컬 변수를 사용할 때, 
//    바깥 함수의 호출이 끝나면 해당 로컬 변수가 제거되기 때문에
//    클로저는 존재하지 않는 변수를 사용하는 상황이 발생한다.
//    그래서 이런 경우를 방지하고자, 
//    클로저에서 사용하는 바깥 함수의 로컬 변수는 클로저의 별도 메모리에 복제된다.
//
//
function closureMaker(fnType, count) { // 잊지말라 파라미터도 로컬 변수이다.
	switch (fnType) {
	case "sum":
	    return function() { 
		    // 이렇게 클로저를 정의하는 순간 클로저가 사용하는 바깥 함수의 로컬 변수 count는
		    // 클로저가 관리하는 별도의 메모리에 복제된다.
		    // 따라서 바깥 함수의 실행이 끝나 그 로컬 변수가 사라지더라도 
		    // 클로저는 복제된 변수를 계속 사용할 수 있다.
	        var sum = 0;     
	        for (var i = 1; i <= count; i++) {
	            sum += i;
	        }
	        console.log("합계 =", sum);
	    };
	case "factorial":
        return function() {
	        var sum = 1;
	        for (var i = 1; i <= count; i++) {
	            sum *= i;
	        }
	        console.log("팩토리얼 =", sum);
	    };
	default:
	    return function() {
		    console.log("해당 연산을 지원하지 않습니다.");
		};
	}
}

var fn1 = closureMaker("sum", 10);
var fn2 = closureMaker("factorial", 10);

fn1();
fn2();

</script>

</body>
</html>





